{"version":3,"sources":["../src/index.js"],"names":["createContainer","Definition","providerOrDescriptor","updateMethod","dependenciesOrAnnotations","annotations","provider","dependencies","descriptor","Array","isArray","FactoryProviderLabel","ClassProviderLabel","TransientLabel","Container","parent","instances","providers","definitions","token","has","get","factory","definition","undefined","set","names","name","push","primaryDefinition","Error","getFromCache","options","instance","normalizeToken","promiseOrInstance","updateInstance","maybeCacheInstance","createInstance","loadDependencies","getProvider","updateInstanceDependencies","call"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\n// todo should we call updateDependencies for the first time?\n\nimport {isFunction, isString, isObject, zipObject, all, then, hasAnnotation} from './utils';\nimport {createProvider} from './providers';\n\ndeclare type Instance = Object;\ndeclare type Token = Definition | Function;\ndeclare type Provider = Definition | Function;\ndeclare type UpdateMethod = Function | string;\ndeclare type DependenciesDescriptor = {[name: string]: Token};\ndeclare type Dependencies = {[name: string]: Instance};\ndeclare type Annotation = typeof FactoryProviderLabel | typeof ClassProviderLabel;\ndeclare type Annotations = Array<Annotation>;\ndeclare type PrimaryDefinition = Definition & {provider: Function};\n\nexport class Definition {\n    provider: Provider;\n    updateMethod: UpdateMethod;\n    dependencies: DependenciesDescriptor;\n    annotations: Annotations;\n\n    constructor(providerOrDescriptor: Provider | Object,\n                updateMethod?: UpdateMethod,\n                dependenciesOrAnnotations ?: DependenciesDescriptor | Annotations = {},\n                annotations ?: Annotations = []) {\n        let provider = providerOrDescriptor;\n        let dependencies;\n\n        // todo up updateMethod from provider chain\n        // todo collect dependencies, annotations from provider chain\n\n        if (!isFunction(providerOrDescriptor)) {\n            let descriptor = providerOrDescriptor;\n            provider = descriptor.provider;\n            updateMethod = descriptor.updateMethod;\n            dependencies = descriptor.dependencies || {};\n            annotations = descriptor.annotations || [];\n        } else if (Array.isArray(dependenciesOrAnnotations)) {\n            dependencies = {};\n            annotations = dependenciesOrAnnotations;\n        } else {\n            dependencies = dependenciesOrAnnotations;\n        }\n\n        Object.assign(this, {provider, updateMethod, dependencies, annotations});\n    }\n\n}\n\nexport class FactoryProviderLabel {\n}\n\nexport class ClassProviderLabel {\n}\n\nexport class TransientLabel {\n}\n\nclass Container {\n    parent: Container | void;\n    instances: Map<Token, Instance>;\n    providers: Map<Definition, Function>;\n    definitions: Map<Token, Definition>;\n\n    constructor({parent} : {parent:? Container} = {}) {\n        this.parent = parent;\n        this.instances = new Map();\n        this.providers = new Map();\n        this.definitions = new Map();\n    }\n\n    normalizeToken(token: Token): Definition {\n        // todo parent definitions\n        if (this.definitions.has(token)) {\n            return this.definitions.get(token);\n        } else if (token instanceof Definition) {\n            return token;\n        } else {\n            let provider = isFunction(token.factory) ? token.factory : token; // todo why should we do this?\n            let definition = new Definition(provider, undefined, token.dependencies, token.annotations);\n            this.definitions.set(token, definition);\n            return definition;\n        }\n    }\n\n    loadDependencies(dependencies: DependenciesDescriptor): Dependencies | Promise<Dependencies> {\n        let names = [], instances = [];\n\n        for (let [name, token] of Object.entries(dependencies)) {\n            names.push(name);\n            instances.push(this.get(token));\n        }\n\n        return all(instances, (instances) => {\n            return zipObject(names, instances);\n        });\n    }\n\n    getProvider(definition: Definition): Function {\n        if (this.providers.has(definition)) {\n            return this.providers.get(definition);\n        } else {\n            let primaryDefinition = definition;\n            while (primaryDefinition.provider instanceof Definition) {\n                primaryDefinition = primaryDefinition.provider;\n            }\n            if (typeof primaryDefinition.provider !== 'function') {\n                throw new Error(`Expected provider to be a class or a function`);\n            }\n            let provider = createProvider(primaryDefinition);\n            this.providers.set(definition, provider);\n            return provider;\n        }\n    }\n\n    getFromCache(definition: Definition): Instance | void {\n        if (this.instances.has(definition)) {\n            return this.instances.get(definition);\n        } else if (this.parent) {\n            return this.parent.getFromCache(definition);\n        }\n    }\n\n    get(token: Token, options?: Object): Promise<Instance> | Instance {\n        let instance, definition = this.normalizeToken(token);\n\n        if (this.instances.has(definition)) {\n            return this.instances.get(definition);\n        } else if (instance = this.getFromCache(definition)) {\n            let promiseOrInstance = this.updateInstance(instance, definition);\n            this.maybeCacheInstance(promiseOrInstance, definition);\n            return promiseOrInstance;\n        } else {\n            let promiseOrInstance = this.createInstance(definition, options);\n            this.maybeCacheInstance(promiseOrInstance, definition);\n            return promiseOrInstance;\n        }\n    }\n\n    maybeCacheInstance(instance, definition) {\n        if (!hasAnnotation(definition, TransientLabel)) {\n            this.instances.set(definition, instance);\n        }\n    }\n\n    createInstance(definition: Definition, options?: Object = {}): Promise<Instance> | Instance {\n        return then(this.loadDependencies(definition.dependencies), (dependencies) => {\n            let provider = this.getProvider(definition);\n            let instance = provider(Object.assign({}, dependencies, options));\n            this.maybeCacheInstance(instance, definition);\n            return this.updateInstanceDependencies(instance, definition, dependencies);\n        });\n    }\n\n    updateInstance(instance: Instance, definition: Definition): Promise<Instance> | Instance {\n        return then(this.loadDependencies(definition.dependencies), (dependencies) => {\n            return this.updateInstanceDependencies(instance, definition, dependencies);\n        });\n    }\n\n    updateInstanceDependencies(instance, definition, dependencies): Instance {\n        let updateMethod = definition.updateMethod || 'updateDependencies';\n        if (isString(updateMethod) && isObject(instance)) {\n            updateMethod = instance[updateMethod];\n        }\n        if (isFunction(updateMethod)) {\n            updateMethod.call(instance, dependencies);\n        }\n        return instance;\n    }\n\n    // todo should we pass definitions / providers?\n    createSession() {\n        return new Container({\n            parent: this\n        });\n    }\n\n    closeSession() {\n        this.parent = undefined;\n    }\n\n}\n\nexport function createContainer() {\n    return new Container();\n}\n"]}